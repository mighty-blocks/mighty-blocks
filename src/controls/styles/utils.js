/**
 * External dependencies
 */
import memize from 'memize';
import {
	camelCase,
	isUndefined,
	isString,
	isPlainObject,
} from 'lodash';

/**
 * WordPress dependencies
 */
import { applyFilters } from '@wordpress/hooks';
import { hasBlockSupport, getBlockSupport } from '@wordpress/blocks';

/**
 * Returns the client identifiers of the blocks that have support
 * for our controls.
 *
 * @param  {Object[]} blocks
 * @return {string[]}
 */
export const getBlocksWithControls = memize( ( blocks ) => {
	const walk = ( memo, block ) => {
		const {
			clientId,
			name,
			attributes,
		} = block;

		if (
			hasBlockSupport( name, 'controls' ) &&
			! isUndefined( attributes.mightyBlocksId )
		) {
			memo.push( {
				clientId,
				name,
				attributes,
				breakpoints: getBlockSupport( name, 'breakpoints' ),
				controls: getBlockSupport( name, 'controls' ),
			} );
		}

		return block.innerBlocks.reduce( walk, memo );
	};

	return blocks.reduce( walk, [] );
} );

/**
 * Return a CSS selector applied to generated styles.
 *
 * @param  {Object} control
 * @param  {string} context
 * @return {?string}
 */
export function getControlCssSelector( control, context ) {
	if ( isUndefined( control.selector ) ) {
		return;
	}

	if ( isString( control.selector ) ) {
		return `${ control.selector }`;
	}

	if ( isPlainObject( control.selector ) ) {
		return control.selector[ context ];
	}
}

/**
 * Returns the block's styles generated by the controls.
 *
 * @param  {Object} block
 * @param  {string} context
 * @return {Object}
 */
export function getBlockStyles( block, context ) {
	return block.controls.reduce( ( memo, control ) => {
		const {
			attributes,
			breakpoints,
			states,
		} = block;

		const selector = getControlCssSelector( control, context );
		const styles = applyFilters( 'mighty-blocks.controls.getStyles', {}, control, {
			attributes,
			breakpoints,
			states,
		} );

		if ( selector ) {
			memo.push( {
				[ selector ]: styles,
			} );
		} else {
			memo.push( styles );
		}

		return memo;
	}, [] );
}

/**
 * Conditonally wraps the provided styles in a CSS rule that applies
 * a media query.
 *
 * @param  {Object} styles
 * @param  {Object} breakpoint
 * @return {Object}
 */
export function maybeWrapStylesInMediaRule( styles, breakpoint ) {
	if ( ! breakpoint.size ) {
		return styles;
	}

	return {
		[ `@media (max-width: ${ breakpoint.size })` ]: styles,
	};
}

/**
 * Conditonally wraps the provided styles in a CSS rule that
 * applies a pseudo state.
 *
 * @param  {Object} styles
 * @param  {Object} state
 * @return {Object}
 */
export function maybeWrapStylesInStateRule( styles, state ) {
	if ( ! state.pseudo ) {
		return styles;
	}

	return {
		[ state.pseudo ]: styles,
	};
}

/**
 * Returns a prefixed version of the specified CSS property.
 *
 * @param  {string} property
 * @param  {string} [prefix]
 * @return {string}
 */
export function getPrefixedProperty( property, prefix ) {
	return camelCase( prefix ? `${ prefix }-${ property }` : property );
}
